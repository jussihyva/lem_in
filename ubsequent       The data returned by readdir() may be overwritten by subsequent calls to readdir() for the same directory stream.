READDIR(3)                                       Linux Programmer's Manual                                      READDIR(3)

NNAAMMEE
       readdir - read a directory

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ddiirreenntt..hh>>

       ssttrruucctt ddiirreenntt **rreeaaddddiirr((DDIIRR **_d_i_r_p));;

DDEESSCCRRIIPPTTIIOONN
       The  rreeaaddddiirr() function returns a pointer to a _d_i_r_e_n_t structure representing the next directory entry in the direc‐
       tory stream pointed to by _d_i_r_p.  It returns NULL on reaching the end  of  the  directory  stream  or  if  an  error
       occurred.

       In the glibc implementation, the _d_i_r_e_n_t structure is defined as follows:

           struct dirent {
               ino_t          d_ino;       /* Inode number */
               off_t          d_off;       /* Not an offset; see below */
               unsigned short d_reclen;    /* Length of this record */
               unsigned char  d_type;      /* Type of file; not supported
                                              by all filesystem types */
               char           d_name[256]; /* Null-terminated filename */
           };

       The  only  fields  in the _d_i_r_e_n_t structure that are mandated by POSIX.1 are _d___n_a_m_e and _d___i_n_o.  The other fields are
       unstandardized, and not present on all systems; see NOTES below for some further details.

       The fields of the _d_i_r_e_n_t structure are as follows:

       _d___i_n_o  This is the inode number of the file.

       _d___o_f_f  The value returned in _d___o_f_f is the same as would be returned by calling tteellllddiirr(3) at the  current  position
              in  the  directory  stream.   Be aware that despite its type and name, the _d___o_f_f field is seldom any kind of
              directory offset on modern filesystems.  Applications should treat this field as an opaque value, making  no
              assumptions about its contents; see also tteellllddiirr(3).

       _d___r_e_c_l_e_n
              This is the size (in bytes) of the returned record.  This may not match the size of the structure definition
              shown above; see NOTES.

       _d___t_y_p_e This field contains a value indicating the file type, making it possible to avoid  the  expense  of  calling
              llssttaatt(2) if further actions depend on the type of the file.

              When  a suitable feature test macro is defined (__DDEEFFAAUULLTT__SSOOUURRCCEE on glibc versions since 2.19, or __BBSSDD__SSOOUURRCCEE
              on glibc versions 2.19 and earlier), glibc defines the following macro constants for the value  returned  in
              _d___t_y_p_e:

              DDTT__BBLLKK      This is a block device.

              DDTT__CCHHRR      This is a character device.

              DDTT__DDIIRR      This is a directory.

              DDTT__FFIIFFOO     This is a named pipe (FIFO).

              DDTT__LLNNKK      This is a symbolic link.

              DDTT__RREEGG      This is a regular file.

              DDTT__SSOOCCKK     This is a UNIX domain socket.

              DDTT__UUNNKKNNOOWWNN  The file type could not be determined.

              Currently,  only  some filesystems (among them: Btrfs, ext2, ext3, and ext4) have full support for returning
              the file type in _d___t_y_p_e.  All applications must properly handle a return of DDTT__UUNNKKNNOOWWNN.

       _d___n_a_m_e This field contains the null terminated filename.  _S_e_e _N_O_T_E_S.

       The data returned by rreeaaddddiirr() may be overwritten by subsequent calls to rreeaaddddiirr() for the same directory stream.

RREETTUURRNN VVAALLUUEE
       On success, rreeaaddddiirr() returns a pointer to a _d_i_r_e_n_t structure.  (This structure may be statically allocated; do not
       attempt to ffrreeee(3) it.)

       If the end of the directory stream is reached, NULL is returned and _e_r_r_n_o is not changed.  If an error occurs, NULL
       is returned and _e_r_r_n_o is set appropriately.  To distinguish end of stream and from an  error,  set  _e_r_r_n_o  to  zero
       before calling rreeaaddddiirr() and then check the value of _e_r_r_n_o if NULL is returned.

EERRRROORRSS
       EEBBAADDFF  Invalid directory stream descriptor _d_i_r_p.

AATTTTRRIIBBUUTTEESS
       For an explanation of the terms used in this section, see aattttrriibbuutteess(7).

       ┌──────────┬───────────────┬──────────────────────────┐
       │IInntteerrffaaccee │ AAttttrriibbuuttee     │ VVaalluuee                    │
       ├──────────┼───────────────┼──────────────────────────┤
       │rreeaaddddiirr() │ Thread safety │ MT-Unsafe race:dirstream │
       └──────────┴───────────────┴──────────────────────────┘

       In the current POSIX.1 specification (POSIX.1-2008), rreeaaddddiirr() is not required to be thread-safe.  However, in mod‐
       ern implementations (including the glibc implementation), concurrent calls  to  rreeaaddddiirr()  that  specify  different
       directory streams are thread-safe.  In cases where multiple threads must read from the same directory stream, using
       rreeaaddddiirr() with external synchronization is still preferable to the use of the deprecated rreeaaddddiirr__rr(3) function.  It
       is  expected that a future version of POSIX.1 will require that rreeaaddddiirr() be thread-safe when concurrently employed
       on different directory streams.

CCOONNFFOORRMMIINNGG TTOO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

NNOOTTEESS
       A directory stream is opened using ooppeennddiirr(3).

       The order in which filenames are read by successive calls to rreeaaddddiirr() depends on the filesystem implementation; it
       is unlikely that the names will be sorted in any fashion.

       Only  the  fields  _d___n_a_m_e  and  (as an XSI extension) _d___i_n_o are specified in POSIX.1.  Other than Linux, the _d___t_y_p_e
       field is available mainly only on BSD systems.  The remaining fields are available on many, but  not  all  systems.
       Under  glibc,  programs  can check for the availability of the fields not defined in POSIX.1 by testing whether the
       macros __DDIIRREENNTT__HHAAVVEE__DD__NNAAMMLLEENN, __DDIIRREENNTT__HHAAVVEE__DD__RREECCLLEENN, __DDIIRREENNTT__HHAAVVEE__DD__OOFFFF, or __DDIIRREENNTT__HHAAVVEE__DD__TTYYPPEE are defined.

   TThhee dd__nnaammee ffiieelldd
       The _d_i_r_e_n_t structure definition shown above is taken from the glibc headers, and shows  the  _d___n_a_m_e  field  with  a
       fixed size.

       _W_a_r_n_i_n_g:  applications  should  avoid  any  dependence  on  the  size  of  the  _d___n_a_m_e  field.  POSIX defines it as
       _c_h_a_r _d___n_a_m_e_[_], a character array of unspecified size, with at most NNAAMMEE__MMAAXX characters  preceding  the  terminating
       null byte ('\0').

       POSIX.1  explicitly notes that this field should not be used as an lvalue.  The standard also notes that the use of
       _s_i_z_e_o_f_(_d___n_a_m_e_)  is  incorrect;  use  _s_t_r_l_e_n_(_d___n_a_m_e_)  instead.   (On  some  systems,  this  field  is   defined   as
       _c_h_a_r _d___n_a_m_e_[_1_]!)   By  implication,  the  use _s_i_z_e_o_f_(_s_t_r_u_c_t _d_i_r_e_n_t_) to capture the size of the record including the
       size of _d___n_a_m_e is also incorrect.

       Note that while the call

           fpathconf(fd, _PC_NAME_MAX)

       returns the value 255 for most filesystems, on some filesystems (e.g., CIFS, Windows SMB servers), the  null-termi‐
       nated  filename  that is (correctly) returned in _d___n_a_m_e can actually exceed this size.  In such cases, the _d___r_e_c_l_e_n
       field will contain a value that exceeds the size of the glibc _d_i_r_e_n_t structure shown above.

SSEEEE AALLSSOO
       ggeettddeennttss(2), rreeaadd(2), cclloosseeddiirr(3), ddiirrffdd(3), ffttww(3), ooffffsseettooff(3),  ooppeennddiirr(3),  rreeaaddddiirr__rr(3),  rreewwiinnddddiirr(3),  ssccaann‐‐
       ddiirr(3), sseeeekkddiirr(3), tteellllddiirr(3)

CCOOLLOOPPHHOONN
       This  page is part of release 4.15 of the Linux _m_a_n_-_p_a_g_e_s project.  A description of the project, information about
       reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

                                                        2017-09-15                                              READDIR(3)
